---
date: 2025-12-07 18:30:00
updated: 2025-12-07 18:30:00
title: 字符串 - PAM
katex: true
tags:
- Algo
- C++
- String
categories:
- XCPC
description: 回文自动机。
---

## PAM

回文自动机是能够存储所有回文子串的数据结构，下面是几个概念：

1. 节点：每一个节点代表一种回文串，下面用 $S_u$ 表示节点 $u$ 代表的回文子串。
2. 后继边：每个后继边上有一个字母，若 $v=\text{trans}(u,\texttt{ch})$ 表示 $S_v=\texttt{ch} S_u\texttt{ch}$，那么 $|S_v|=|S_u|+2$。
3. 失配边：每个节点都有失配边，若 $v=\text{fail}(u)$ 表示 $S_v$ 是 $S_u$ 的最大回文后缀。

由于长度为奇数的回文串与长度为偶数的回文串情况不仅相同，所以在 PAM 中有两个根节点 $0,1$ 分别表示空的长度为奇数、偶数的串，并且令 $\text{fail}(0)=1,\text{fail}(1)=0$，下文中我们通过构建过程来说明这是为什么。

首先给出一个初始化的函数，这里 `tot` 表示字符的数量，`idx` 表示节点的数量，`last` 表示上一次操作后插入的字符对应的节点并且初始值为 $0$，`len[u]` 表示 $|S_u|$。

```cpp
int tot, idx, last;
int fail[N], tr[N][26], len[N];
char s[N];

int create(int l) {
    idx++;
    memset(tr[idx], 0, sizeof tr[idx]);
    len[idx] = l;
    fail[idx] = 0;
    return idx;
}

void init() {
    idx = -1;
    tot = 0;
    s[0] = '$';
    last = 0;
    create(0);
    create(-1);
    fail[0] = 1;
}
```

当我们插入一个新的字符 $\texttt{ch}$ 时，先将 $\texttt{ch}$ 加到 PAM 中保存的 $s$ 的末尾，令 $now=last$，尝试通过 $\text{trans}(now, \texttt{ch})$ 边，如果不行就 $now\gets \text{fail}(now)$，一直跳到行为止。

为什么？因为以当前位置结尾的回文串，扣掉最后一个位置和第一个位置后，前面一定也是一个回文子串，所以我们从前一个位置结尾的最长回文子串开始转移是合适的。

如果转移合法，表示当前串结尾是 $\text{ch}S_{now}\text{ch}$，我们只需检查 $s_{tot-|S_{now}|-1}$ 是否等于 $s_{tot}$ 即可。

然后，当前节点的失配指针就尝试从 $\text{fail}(now)$ 向下添加即可，所以我们可以定义一个 `getfail` 函数辅助我们跳 $\text{fail}$ 链。

当所有尝试都失败时，我们面临向空串插入一个字符的情境，这仍然会有两种可能性：

1. 以 $\texttt{ch}\texttt{ch}$ 的形式，此时它应当满足 $s_{tot-1}=s_{tot}$，从根节点 $0$ 转移过来，失配指针指向 $0$。
2. 以 $\texttt{ch}$ 的形式，此时它应当满足 $s_{tot}=s_{tot}$，从根节点 $1$ 转移过来，失配指针指向 $0$。

为什么失配指针都指向 $0$？因为我们要先检查能不能凑成长度为 $2$ 的串，容易检查我们让 $0,1$ 的失配指针互相指就可以达成这个目的。

```cpp
int getfail(int x) {
    while (s[tot - 1 - len[x]] != s[tot]) x = fail[x];
    return x;
}

int insert(char ch) {
    s[++tot] = ch;
    int now = getfail(last);
    int p = ch - 'a';
    if (!tr[now][p]) {
        int x = create(len[now] + 2);
        fail[x] = tr[getfail(fail[now])][p];
        tr[now][p] = x;
    }
    return last = tr[now][p];
}
```

复杂度仍然可通过势能分析，设势能为当前 $\text{fail}$ 链的长度，每跳一步 $\text{fail}$ 链会让势能减 $1$，插入一个字符后势能加 $1$，所以复杂度仍然为线性。

## [APIO2014] 回文串

我们可以对每一个位置考虑，以这个位置结尾的回文子串都出现在它的 $\text{fail}$ 链上，所以相当于每个节点会给它的整个 $\text{fail}$ 链加一。

每次插入的时候给 $last$ 加一，最后进行一遍 DFS 即可。

由于 PAM 是在线的数据结构，每一个节点的 $\text{fail}$ 编号一定比它本身的编号要小，所以我们直接按照节点编号从大到小遍历，就可以正确的更新答案。

注意，ACAM 并没有这个性质，因为在 ACAM 中是把所有字典串都插入完，再设置的失配指针，所以这个失配指针指向的节点编号并不一定比当前节点编号小。

[AC Code](https://gist.github.com/hikariyo/d1f9e9033f0e5dc4479e640fe3f39b27)。

## [ICPC2019 Xuzhou Online] Colorful String

每一个节点用一个二进制数表示 $26$ 个字母的状态，最后用 $\text{popcount}$ 求每个节点对应的种类数，乘上对应的出现次数累加即可。

[AC Code](https://gist.github.com/hikariyo/81cb1d580cc55be1fa8efcbc2804f7ec)。

## [CCPC2023 Qinhuangdao] Palindrome

我们把每次询问的子串称为 $S$，我们下面讨论基于 $S$ 不是一个回文串。

由于我们可以删除一个区间 $S[l,r]$ 使剩下的部分 $S[1,l-1]+S[r+1,|S|]$ 是回文串，于是分两种情况讨论。

1. 如果 $l=1$ 或者 $r=|S|$，即删除的是一段前缀/后缀，需要保证剩余的部分是一个回文子串。
2. 否则，没删除的前后缀需要对应相等。

不妨设删除的部分是在前半段，最后会说怎么处理后半段。

这就启发我们思考，这个前后缀对应相等的长度，是不是越长越好？接下来尝试证明：如果当前删除的区间是 $S[l,r]$，并且有 $S_l=S_{|S|-l+1}$，那么我们把 $l,r$ 向右平移一个位置，容易验证剩下的部分仍然是一个回文串。

于是我们可以断定，使得前后缀对应相等的长度尽可能长，答案一定不会更劣，所以我们先二分找到一个最大长度。

把这个前后缀扔掉，求删除的最小长度等价于求最长的回文后缀，这可以通过 PAM 上倍增跳 $\text{fail}$ 实现。

接下来考虑方案数。由上文的论述，我们不可能再把 $l,r$ 向右移动，于是只能尝试向左移动。如果这个窗口可以移动，意味着移动后释放出来的那个字符等于吃进去的那个字符，所以这里也可以二分。

如果删除的部分是后半段，把整个字符串翻转过来即可，最后比较翻转前后求出来的答案以及方案数，如果答案相等方案数相加即可。

这不可能会重复，因为扔掉对应相等的前后缀后，求得的最长回文后缀长度至少为 $1$，也就是翻转前删除的部分一定不包含最后一个字符，而翻转后删除的部分一定会包含这个字符，于是它们是不会重复的。

[AC Code](https://gist.github.com/hikariyo/0c2b6b2b25a1d94e149773cac0f7b9cf)。

## [CCPC2025 Jinan] I Love CCPC

一个合法串可以被看作一个字符加上一个长度 $\ge 3$ 的回文串，并且要求前两个字符相等。

左右插入字符的操作方式，启发我们按照增量的方式思考这个问题。

然而 PAM 只支持在一侧添加新字符，所以我们应当先把最终的串离线下来，接下来我们以右侧操作举例。

我们应当把前缀预先加入 PAM 中，然后处理某一个右侧的操作时，答案的添加量应当是以当前位置结尾的合法串，并且长度 $\le$ 当前状态的窗口大小。所以这个合法的答案一定在失配链上。

如果先不考虑长度的限制，那么统计数量的时候，除了最底部的串，失配链上的串我们都可以知道它们的前一个字符是什么。因此可以预处理出整个链上的答案。对于最底部的串，只需要单独判断一下即可。

接下来考虑长度限制怎么办。假设当前窗口的大小是 $L$，那么回文串的长度 $+1\le L$。这个 $+1$ 指的是最开头的那个字符。

这样的话，我们倍增跳失配链，找到第一个满足条件的即可。

左侧的操作也是类似，这样的复杂度是 $O(|s|\log |s|)$。

[AC Code](https://gist.github.com/hikariyo/00f928b0f39f58519b78bb814c5a773f)。

## [SHOI2011] 双倍回文

建完 PAM 后枚举所有的节点。

对于每一个节点 $u$，如果它可能是答案，当且仅当它有一个长度为 $\cfrac{|S_u|}{2}$ 的回文后缀。

怎么找？我们可以倍增找出第一个长度 $\le \cfrac{|S_u|}{2}$ 的回文后缀，然后验证一下即可，复杂度 $O(|s|\log |s|)$。

[AC Code](https://gist.github.com/hikariyo/94d384b5e74d11834bb0b8d44a973cba)。
