---
date: 2025-10-29 23:50:00
title: "[CF2145F] Long Journey"
katex: true
tags:
- Algo
- C++
- Math
- Graph
categories:
- XCPC
description: 图论结合一些数论知识与 Flyod 矩阵结合求最短路。
---

## 题目

[CF2145F](https://codeforces.com/contest/2145/problem/F)。

## 思路

首先，设当前经过了 $s$ 步，并且令 $a_0=a_n,b_0=b_n$，那么题目的意思可以翻译为：

当 $s\bmod n=j$ 时，所有 $x\equiv b_j\pmod{a_j}$ 的 $x$ 会不能走，$s=0$ 时除外。

由于 $a_i$ 的范围是 $2\sim 10$，而它们的 LCM 是 $M=2520$，所以 $0\sim M$ 和 $M\sim 2M$ 等等的状态是相同的。

所以，我们把每一个点 $x$ 分出 $n$ 个状态来，其中 $(x,j)$ 表示走到点 $x$ 时 $s\bmod n=j$。

显然，所有 $x\equiv b_j\pmod{a_j}$ 的点都是不可到达的。对于可到达的点，我们可以这样造边：
$$
(x,j)\to (x+1,(j+1)\bmod n)\\
(x,j)\to (x,(j+1)\bmod n)
$$
这些边的长度都是 $1$，因此可以通过 BFS 求出最短路 $dis_{x,j}$。

当 $m<M$ 时，自然 $\min_{j=0}^{n-1}dis_{m,j}$ 就是答案。当 $m\ge M$ 时，我们需要另外讨论。

不难发现，虽然 $0\sim M,M\sim 2M$ 的状态是相同的，但是我们起始时间对 $n$ 的模是不一定的。

于是，可以设 $G_{i,j}$ 表示起始时间 $\bmod n=i$，到 $M$ 点时的时间 $\bmod n=j$。

这从实现上来说，只是将起始点从 $(0,0)$ 变成了 $(0,i)$，别的都没有什么变化。

然后我们考虑 $G^2_{i,j}$ 表示 $0\sim 2M$ 的对应起始和结束时间，考虑能否通过 $G_{i,j}$ 得到：

显然，我们可以有这样的式子：
$$
G^2_{i,j}=\min_{k=0}^{n-1} \{G_{i,k}+G_{k,j}\}
$$
这是符合 Flyod 矩阵的定义的，于是主要的问题我们已经解决了，接下来具体实现上还有一些细节。

## 实现

对于 $(0,0)$ 这个点，如果真的是起始点，根据题目的定义，它不会是陷阱；但是如果是 $(kM,0)$ 它就有可能是陷阱。所以我们做 BFS 的时候需要特判这种情况，并且令最开始的矩阵是特殊的 $G_0$；其次，对于一个 $m$，它并不一定正好是 $M$ 的倍数，我们需要关心 $m\bmod M$ 的这一段。事实上，我们只需要记录 $H_{i,j}=dis_{m\bmod M,j}$，那么最终乘起来的矩阵是：
$$
R=G_0\times G^{\lfloor m/M\rfloor-1}\times H
$$
答案是 $\min_{j=0}^{n-1} R_{0,j}$。

由于需要多次调用 BFS，所以我们通过时间戳的方式来标记某个点是否到达，这样可以不用每次都清空 `vis` 数组。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int INF = 1e18;
const int M = 2520, N = 11;
int n, m, a[N], b[N];

template<typename T>
void chmin(T& v, T x) {
    v = min(v, x);
}

struct Matrix {
    int dat[N][N];

    Matrix() {
        memset(dat, 0, sizeof dat);
    }

    Matrix operator*(const Matrix& mat) const {
        Matrix res;
        for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) res.dat[i][j] = INF;
        for (int i = 0; i < n; i++)
            for (int k = 0; k < n; k++)
                for (int j = 0; j < n; j++)
                    chmin(res.dat[i][j], dat[i][k] + mat.dat[k][j]);
        return res;
    }

    Matrix pow(int k) const {
        Matrix res;
        for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) res.dat[i][j] = INF;
        for (int i = 0; i < n; i++) res.dat[i][i] = 0;
        Matrix a = *this;
        while (k) {
            if (k & 1) res = res * a;
            a = a * a;
            k >>= 1;
        }
        return res;
    }
};

struct Point {
    int i, j;

    bool valid() {
        return i % a[j] != b[j];
    }
};
int vis[M+1][N];
int dis[M+1][N];
bool trap[M+1][N];

void bfs(Point start, bool specialStart) {
    static int ts;
    ++ts;
    queue<Point> q;
    q.push(start);

    for (int i = 0; i <= M; i++)
        for (int j = 0; j < n; j++)
            dis[i][j] = INF;
    if (!start.valid() && !specialStart) {
        return;
    }

    dis[start.i][start.j] = 0;

    while (q.size()) {
        Point t = q.front();
        q.pop();
        if (vis[t.i][t.j] == ts) continue;

        vis[t.i][t.j] = ts;

        Point nxt = {t.i, (t.j+1) % n};
        if (nxt.valid()) {
            chmin(dis[nxt.i][nxt.j], dis[t.i][t.j] + 1);
            q.push(nxt);
        }

        if (t.i+1 <= M) {
            nxt = {t.i+1, (t.j+1) % n};
            if (nxt.valid()) {
                chmin(dis[nxt.i][nxt.j], dis[t.i][t.j] + 1);
                q.push(nxt);
            }
        }
    }
}

int solve() {
    cin >> n >> m;

    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> b[i];
    a[0] = a[n], b[0] = b[n];

    if (m < M) {
        bfs({0, 0}, true);
        int ans = INF;
        for (int j = 0; j < n; j++) {
            chmin(ans, dis[m][j]);
        }
        return ans;
    }

    Matrix G, H, G0;

    bfs({0, 0}, true);
    for (int k = 0; k < n; k++) {
        G0.dat[0][k] = dis[M][k];
    }

    for (int j = 0; j < n; j++) {
        bfs({0, j}, false);
        for (int k = 0; k < n; k++) {
            if (j != 0) G0.dat[j][k] = dis[M][k];
            G.dat[j][k] = dis[M][k];
            H.dat[j][k] = dis[m % M][k];
        }
    }

    Matrix R = G0 * G.pow(m / M - 1) * H;
    int ans = INF;
    for (int j = 0; j < n; j++) {
        chmin(ans, R.dat[0][j]);
    }
    return ans;
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        int ans = solve();
        if (ans >= INF) ans = -1;
        cout << ans << '\n';
    }
    return 0;
}
```

