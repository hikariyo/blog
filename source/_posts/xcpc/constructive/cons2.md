---
date: 2026-02-07 15:30:00
updated: 2026-02-07 15:30:00
title: 构造 - 专题训练 II
katex: true
tags:
- Algo
- C++
- Constructive
categories:
- XCPC
description: 本专题记录广义的构造题目，只要带有构造性步骤的都算，每篇文章至多 10 题。
---

## [CF1463B] Find The Array

考虑构造出一种情况 $b_i,b_{i+1}$ 之间的约束条件永真，一个自然的想法是令 $b_i$ 为 $2$ 的幂。

既然是 $2$ 的幂次，那就让每一个绝对值里的值尽可能小，所以这里找 $k$ 使得 $2^k \le a_i<2^{k+1}$。

此时 $2\sum |a_i-b_i|=\sum(2a_i-2^{k+1})<\sum a_i=S$。

题解给出了另一种方法，既然想让这个约束条件永真，只要相邻两个元素有一个 $1$ 也能满足这一点，自然另一个就填对应的 $a_i$。

然后，$2\sum_{i=\texttt{odd}}(a_i-1)+2\sum_{i=\texttt{even}} (a_i-1)=2S-2n$，所以一定有一个值 $\le S-n<S$。

[AC Code](https://gist.github.com/hikariyo/184ed2cf1de1c8b6aa7507b53ac9856c)。

## [CF1366D] Two Divisors

首先，$(d_1,d_2)\mid d_1+d_2$，所以 $(d_1,d_2)=1$ 是 $(d_1+d_2,a_i)=1$ 成立的必要条件。

进一步地，从算术基本定理的角度考虑，把 $a_i$ 分解后变成 $p_1^{k_1}p_2^{k_2}\dots p_m^{k_m}$。

显然 $m=1$ 时，任意一个非 $1$ 的因子 $d$ 都满足 $p_1\mid d$，不可能找到 $d_1,d_2$ 满足 $d_1\perp d_2$。

当 $m\ge 2$ 时，我们需要找到 $d_1,d_2$ 满足 $d_1\perp d_2$ 并且 $\forall 1\le j\le m, p_j\not\mid d_1+d_2$。

当 $p_j\mid d_1$ 时，$p_j\mid d_1+d_2$ 成立当且仅当 $p_j\mid d_2$，而又因为 $d_1\perp d_2$ 得知这是不可能的。

因此这就给出了一个构造方法，让每一个 $p_j$ 都是 $d_1$ 或 $d_2$ 的因子即可。

[AC Code](https://gist.github.com/hikariyo/0f0750cc82d468770c65bebd28a2ee68)。

## [CF796D] Police Stations

首先，树的性质保证了删掉边的数量 $+1$ 与连通分量数量 $m$ 相等。

设节点数量是 $n$，警局数量去重之后是 $p$，那么 $m\le p$ 是成立的，因为你不可能把 $p$ 个警局放到多于 $p$ 个连通块里面。

又因为题目保证每一个点到最近警局的距离 $\le d$，这里能够给出一个构造方法使得连通块数量达到上界 $p$：做一个多源最短路，找到离每一个点最近的警局，这些点就构成了 $p$ 个不同的连通分量。

[AC Code](https://gist.github.com/hikariyo/841477e1bdf2deec38f271a0a7a5c099)。

## [CF1450C2] Errich-Tac-Toe (Hard Version)

类似于本文第一题的思想，考虑能不能把可能进行的操作分成 $3$ 种，让它们加起来的操作数量等于 $k$，即把 $k$ 个非空白位置按照某种方式划分成三种方案的**无交之并**，那么最小的那种操作方案的操作数量就满足至多为 $\cfrac{k}{3}$。

如果这是一条直线的话，很自然可以想到按照模 $3$ 为 $0,1,2$ 的三种位置分类染色，这样每连续三个格子都会有不同的颜色。

取两个颜色 $A,B$，我们只需要保证颜色为 $A$ 的格子要么是空白、要么是 $\texttt{O}$；颜色为 $B$ 的格子要么是空白、要么是 $\texttt{X}$，就能保证连续三个格子不可能同时是 $\texttt{O}$ 或 $\texttt{X}$。

拓展到平面，此时我们按照下标 $i+j$ 模 $3$ 分类染色，这样每连续三个格子都会有不同的颜色。为什么这么想？因为连续的三个格子一定有一个坐标是不变的，另外一个坐标是 $+0,+1,+2$，因此这某种程度上也是在直线上的结论。

设 $O_i,X_i$ 表示颜色为 $i$ 的初始 $\texttt{O},\texttt{X}$ 的数量，那么 $\sum_{i=0}^3 O_i+\sum_{i=0}^3 X_i=k$。

于是选择 $A,B$ 使得 $O_A+X_B$ 最小，就能保证 $k=\sum_{i=0}^3 O_i+\sum_{i=0}^3 X_i\ge 3(O_A+X_B)$，即 $O_A+X_B\le \cfrac{k}{3}$。

实际的实现中，我们只需要保证选择的一组 $A,B$ 确实 $\le \cfrac{k}{3}$ 即可，根据上面的阐述一定会存在一组 $A,B$ 满足这一条件。

[AC Code](https://gist.github.com/hikariyo/11dde2a212796c195d3098b048859370)。

## [CF1217D] Coloring Edges

首先用拓扑排序判掉 DAG 的情形，下面我们关注有环的情形。

如果有环 $v_1,v_2,\dots,v_k,v_1,v_2,\dots$，由于这里一共只有 $k$ 个互异的整数，则必然会存在一条边 $(a,b)$ 使得 $a>b$，否则根据小于关系的传递性可以推出 $v_1<v_1$，不符合小于关系的反自反性。

因此，只要我们满足每一条边 $(a,b)$ 都有 $a<b$，就可以断定构造出来的图没有环；类似地，如果满足每条边都有 $a>b$，也可以断定构造出来的图没有环。

[AC Code](https://gist.github.com/hikariyo/589e6fecb1fa02a5a0c3abbcb4e8469a)。

## [CF1485D] Multiples and Power Differences

首先，$a_{i,j}$ 的值比较小，我们可以算出来 $M=\operatorname{lcm}(1,2,\dots,16)=720720$ 备用。

这是连续两个位置，与上面那道连续三个位置的要求有些类似。

我们不妨依然按照每个格子下标 $i+j$ 模 $2$ 染色，颜色为 $0$ 的直接填 $M$，颜色为 $1$ 的填 $M+a^{4}_{i,j}$ 即可满足 $a_{i,j}\mid b_{i,j}$。

[AC Code](https://gist.github.com/hikariyo/c3eb2d8aa87b1c89bdb12e6641cb02c6)。

## [CF1370E] Binary Subsequence Rotation

首先，特判掉 $s$ 和 $t$ 的 $0/1$ 对应个数不相等的情况，容易看出如果 $0/1$ 个数对应相等，起码可以通过两两交换让 $s=t$。

接下来我们观察操作序列的性质，如果我们的操作序列某一部分包含了多个相同的元素，如 $0\textbf{1}1101$，它操作之后的结果等价于 $0\textbf{1}01$，因为后面两个 $1$ 操作前后都仍然是 $1$。同理，操作的开头和末尾如果一样的话，我们可以把开头那个位置删掉。

于是，我们的操作序列已经变成了 $0101\dots 01$ 或者 $1010\dots 10$ 这两种。

接下来我们要构造出一种操作方法，并且证明任何操作步数都不会比这种方案更优。

1. 构造操作方法。

   一个常规的思路是，我们可以只关注那些不匹配的位置，把匹配的位置删掉，设剩下的 $s,t$ 的下标为 $1\sim m$。

   给 $s_i=1,t_i=0$ 的位置赋一个权 $w_i=1$；$s_i=0,t_i=1$ 的位置赋一个权 $w_i=-1$。

   根据一开始的论断，我们可以知道不匹配的位置中，$s$ 的 $0/1$ 数量与 $t$ 的 $0/1$ 数量对应相等，又因为这是不匹配的位置，所以 $s$ 的 $0/1$ 数量与 $t$ 的 $1/0$ 数量对应相等。于是 $\sum_{i=1}^m w_i=0$ 是成立的。

   我们可以关注 $S_i=\sum_{j=1}^i w_j$ 的变化，根据上文 $S_m=0$，当 $i=1\sim m$ 时，给出下面的方案，其中 $L_0,L_1,L_{-1}\dots$ 是不同的操作序列：

   1. 当 $w_i=1$ 时，将当前的 $i$ 放到 $L_{S_i}$ 中；
   2. 当 $w_i=-1$ 时，将当前的 $i$ 放到 $L_{S_{i}+1}$ 中，

   例如，当 $s=101100$ 时，会有 $L_1=1,2,3,6$ 且 $L_2=4,5$，容易看出他们对应的操作序列都是 $10\dots 10$。

   手玩可以发现每一个操作序列都是 $1010\dots 10$ 或者 $0101\dots 01$ 这样的，即构造出了一种 $\max_{i=1}^m S_i - \min_{j=1}^m S_j$ 次操作的方案。

2. 证明最优性。

   与构造不一样的是，此时我们需要关注那些已经匹配的位置，并且给匹配的位置 $i$ 赋一个权 $w_i=0$。

   令势能 $\Phi=\max_{i=1}^n S_i-\min_{j=1}^n S_j$，只需证明每一步势能至多减少 $1$ 即可。

   1. 当操作序列是 $0101\dots 01$ 时，我们取两个相邻的操作位置 $i,j$ 并且 $s_i=0, s_j=1$，分别枚举 $t_i,t_j$ 的情况，会发现无论 $t_i,t_j$ 是怎么样的，都有：操作前后 $w_i+w_j$ 相等，即不影响 $S_j\sim S_n$ 的值；对于 $S_i\sim S_{j-1}$，操作后相当于整体 $+1$。
   2. 当操作序列是 $1010\dots 10$ 时，我们取两个相邻的操作位置 $i,j$ 并且 $s_i=1,s_j=0$，分别枚举 $t_i,t_j$ 的情况，会发现无论 $t_i,t_j$ 是怎么样的，都有：操作前后 $w_i+w_j$ 相等，即不影响 $S_j\sim S_n$ 的值；对于 $S_i\sim S_{j-1}$，操作后相等于整体 $-1$。

   所以，每次操作就是给一些连续的段至多 $\pm 1$，并且一次操作中这个加或减的符号是一样的。那么操作次数就一定不少于 $\Phi$。

这个代码是非常好写的，但是构造出来操作方案和证明是比较困难的。

[AC Code](https://gist.github.com/hikariyo/b7aa3dfc162df17b5e0dde2fb8d6ccba)。

## [CF1763C] Another Array Problem

对于这种操作比较复杂并且难以简单比较的题目，我们首先要看一下理论最大值能是多少。

1. 符号：无论进行多少次操作，数组中的元素永远是非负数。
2. 最大值：设当前数组最大值为 $M$，不妨设当前这一步操作 $a_i>a_j$，如果 $a_i-a_j>M$，就有 $a_i>M+a_j\ge M$，即 $a_i>M$，这是不可能的。

如果初始状态下数组中最大值为 $M$，根据上面的结论，无论执行多少次操作，都有 $\forall 1\le i\le n, 0\le a_i\le M$。

那么如果能构造出一种方案使得所有的元素都达到 $M$，就一定是最大的。

如果 $n\ge 4$，位置足够，我们总可以在最大值的左边或右边操作两次清空，然后把这边全部变成 $M$，再把另一边也全部变成 $M$。

如果 $n=2$，那么答案是 $\max(a_1+a_2,2|a_1-a_2|)$；

如果 $n=3$，如果 $M$ 位于 $a_1$ 或者 $a_3$，类比 $n\ge 4$ 的情况，可以构造出 $3M$；如果 $M=a_2$，我们要么不操作，要么操作一次 $(1,2),(1,3),(2,3)$，操作之后就有新的 $M'$ 位于 $a_1$ 或 $a_3$ 了，这里可以写一个简单的 DFS 或者直接分类讨论。

[AC Code](https://gist.github.com/hikariyo/fd47a5ea100e777e23434ec1c1a9a5c4)。
